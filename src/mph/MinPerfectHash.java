package mph;

import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.LinkedList;

/**
 * Minimal Perfect Hash
 * 
 * Class to create minimal hash for given input
 * 
 * @author Michael Yuan
 * 
 */
public class MinPerfectHash {
   final int keysPerBucket = 4;
   int binCount;
   int m;
   int n;

   Poko[] pokos;
   String[] rawData;
   ArrayList<LinkedList<Integer>> buckets;
   int[] dispTable;

   /**
    * Constructor Using an Input File
    * 
    * @param file file being parsed into string array to be hashed
    * @throws IOException
    */
   public MinPerfectHash(String file) throws IOException {
      rawData = Utility.fileToStringArray(file);
   }

   /**
    * Constructor Using an Input Array
    * 
    * @param dataArray array being hashed
    */
   public MinPerfectHash(String[] dataArray) {
      if (dataArray == null || dataArray.length == 0)
         throw new IllegalArgumentException();
      rawData = dataArray;
   }

   /*
    * Initialize Variables
    */
   protected void init() {
      m = rawData.length;
      binCount = m / keysPerBucket + 1;
      n = (int) (m / 0.5d + 1);
      dispTable = new int[binCount];
      if (n % 2 == 0)
         n++;
      while (true) {
         if (Utility.isPseudoPrime(n))
            break;
         n += 2;
      }
      buckets = new ArrayList<LinkedList<Integer>>(binCount);
      for (int i = 0; i < binCount; i++)
         buckets.add(i, new LinkedList<Integer>());
   }

   /**
    * Create Pokos
    * 
    * Create an array of Pokos using the input data
    * 
    * @return
    * @throws NoSuchAlgorithmException
    */
   protected Poko[] mapPokosAndBuckets() throws NoSuchAlgorithmException {
      Poko[] pokos = new Poko[rawData.length];
      for (int i = 0; i < rawData.length; i++) {
         String hexString = Utility.hash256_16bytes(rawData[i], 9);
         pokos[i] = new Poko();
         int bucketNum = Integer.valueOf(hexString.subSequence(0, 6).toString(), 16) % binCount;
         pokos[i].bucketNum = bucketNum;
         pokos[i].f = Integer.valueOf(hexString.subSequence(6, 12).toString(), 16) % n;
         pokos[i].h = Integer.valueOf(hexString.subSequence(12, 18).toString(), 16) % (n - 1) + 1;
         buckets.get(bucketNum).add(i);
      }
      return pokos;
   }

   /*
    * Search for a mapping that maps all the keys
    */
   protected void searchAndPlace(boolean random) {
      boolean[] filled = new boolean[n];
      int index = 0;

      for (LinkedList<Integer> list : buckets) {
         int size = list.size();
         if (size == 0)
            continue;

         int[] probe = new int[2];
         int[] position = new int[size];
         boolean found = false;

         while (!found) {
            found = true;
            int k = 0;
            for (int i : list) {
               position[k] = (pokos[i].f + pokos[i].h * probe[0] + probe[1]) % n;
               if (filled[position[k]]) {
                  found = false;
                  for (int j = 0; j < k; j++)
                     filled[position[j]] = false;
                  break;
               }
               filled[position[k]] = true;
               k++;
            }
            probe[0]++;
            if (probe[0] >= n) {
               probe[0] -= n;
               probe[1]++;
            }
         }

         dispTable[index] = probe[0] + probe[1] * n;
         index++;
      }
   }

   /**
    * Permute the ordering of the buckets TODO: you can write this later.
    */
   protected void permuteBucketOrder() {

   }

   /**
    * Generate Minimal Perfect Hash
    * 
    * Using the given input, generate minimal perfect hash (or perfect hash, undecided yet)
    * 
    * @param random if you need to start at random positions of rho i, then toggle random. Normally
    *        rho i would start at 0
    * @throws NoSuchAlgorithmException
    */

   public void genMPH(boolean random) throws NoSuchAlgorithmException {
      init();
      pokos = mapPokosAndBuckets();
      searchAndPlace(random);
   }

   /**
    * Map Entries
    * 
    * Map the input using a mapping scheme generated by this class
    */
   public void mapEntriesUsingScheme(String mapping) {

   }

   /**
    * Write Bin Mappings
    * 
    * Output the theta i for every bin that was used to achieve perfect mapping
    */
   public void writeMphMapping() {

   }


   /**
    * Plain Old Key Object (Get it?)
    * 
    * @author Michael Yuan
    * 
    */
   protected class Poko {
      protected int bucketNum;
      protected int f;
      protected int h;
   }
}
